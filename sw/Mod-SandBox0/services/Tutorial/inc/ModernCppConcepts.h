#include <iostream>
#include <memory>
#include <cassert>
#include <string>
#include <variant>
#include <vector>

using namespace std;


// //////// CASE: 1 - Klaus Iglberger impl ////////
/*
template<typename Fn>
class function;

template<typename R, typename... Args>
class function<R(Args...)>
{
public:
    template<typename Fn>
    function(Fn fn) : pimpl_( std::make_unique<FuncImpl<Fn>>(fn) )
    {
       std::cout << "function constructor called ..." << '\n';
    }
   
    R operator()(Args... args) const
    {
        std::cout << "function operator() called ..." << '\n';
        return pimpl_->invoke(args...);
    }

    ~function() = default; // unique_ptr will take care of deleting (no need to care)
    function(function&&) = default; // move constructor - unique_ptr will take care
    function& operator=(function&&) = default; // move assign operator easy
   
    // Only 'problem' is copy constructor and copy assign operator (because of unique_ptr)
    // What shozld I copy? All I have is pointer to base (FuncBase)
    // Design pattern - How to copy some apstract think? Prototype Design Pattern
    function(const function& other) : pimpl_(other.pimpl_->clone())
    {
        std::cout << "function copy constructor called ..." << '\n';
    }
   
    function& operator=(const function& other)
    {
        std::cout << "function operator= called ..." << '\n';
        // Temporary-swap idiom
        function tmp(other);
        std::swap(pimpl_, tmp.pimpl_);
       
        return *this;
    }


private:
    struct FuncBase  // External Polymorphism Design Pattern
    {
        virtual ~FuncBase() = default;
        virtual R invoke(Args... args) const = 0;
        virtual std::unique_ptr<FuncBase> clone() const = 0; // Prototype Design Pattern - copy anything
    };

    // Implementation details here are generated by compiler
    template<typename Fn>
    struct FuncImpl : public FuncBase
    {
        // This derived class was missing
        FuncImpl(const Fn& fn) : fn_(fn)
        {
            std::cout << "FuncImpl (inhr) constructor called ..." << '\n';
        }

        R invoke(Args... args) const final
        {
            std::cout << "invoke(Args... args) (inhr) method called ..." << '\n';
            return fn_(args...);
        };

        virtual std::unique_ptr<FuncBase> clone() const final
        {
            std::cout << "clone() (inhr) method called ..." << '\n';
            return std::make_unique<FuncImpl>(*this); // Copy myself
        };

        // Store whatever - function object, func pointer, ...
        Fn fn_;
    };

    std::unique_ptr<FuncBase> pimpl_;  // Pimpl idiom / Bridge Design Pattern (Hide some impl details)
};
*/


// //////// CASE: 2 - Naive impl ////////
// https://shaharmike.com/cpp/naive-std-function/
template <typename T>
class naive_function;

template <typename ReturnValue, typename... Args>
class naive_function<ReturnValue(Args...)> {
public:

    template <typename T>
    naive_function& operator=(T t) {
        std::cout << "naive_function calling operator= ..." << '\n';
        callable_ = std::make_unique<CallableT<T>>(t);
        return *this;
    }

    ReturnValue operator()(Args... args) const {
        std::cout << "naive_function calling operator()(Args... args) ..." << '\n';
        assert(callable_);
        return callable_->Invoke(args...);
    }

private:
    class ICallable {
    public:
        virtual ~ICallable() = default;
        virtual ReturnValue Invoke(Args...) = 0;
    };


template <typename T>
class CallableT : public ICallable {
public:
    CallableT(const T& t)
    : t_(t) {
        std::cout << "CallableT constructor calling ..." << '\n';
    }

    ~CallableT() override = default;
   
    ReturnValue Invoke(Args... args) override {
        std::cout << "CallableT Invoke(Args... args) ..." << '\n';
        return t_(args...);
    }

private:
T t_;
};

std::unique_ptr<ICallable> callable_;
};


//////// Some test functions ////////
void func() {
    cout << "func" << endl;
}


struct functor {
    void operator()() {
        cout << "functor" << endl;
    }
};


/*
// Important! This call will call copy constructor (method clone)
// In order not to call copy constructor, pass by reference
void ff(function<void()> fn)
{
    // Pass fn around like the object
    fn();
}
*/


// Variadic, visitor and Overload Pattern
// Overload Pattern: https://www.modernescpp.com/index.php/visiting-a-std-variant-with-the-overload-pattern

void print(std::variant<bool, int, std::string> result)
{
    // Pass 2nd (variant) arg to 1st arg visitor (lambda)
    // Usually implemented as generic lambda expression
    std::visit( [](const auto& arg) { std::cout << arg << '\n'; }, result );
}
