# ***********************************
# SAMPLE MAKEFILE FOR TARGET - BINARY
# # NOTES:
# We may have to modify attributes
# ***********************************

# This is lazy initialisation, because until
# we use it, it will not be validated.
BUILD_TYPE = $(RELEASE)
# BUILD_TYPE = $(DEBUG)

# Module Folder name
MODULE_NAME = Mod-App-1
# Binary file only name (a.out)
TARGET_NAME = Mod-App-1

PROJ_ROOR_DIR = ../..
# Inside obj folder will be module folder
OBJ_DIR = $(PROJ_ROOR_DIR)/objs/$(MODULE_NAME)



# ******** DO NOT MODIFY BELOW ATTRIBUTES ******** #
BUILD_TIMESTAMP = $(shell date + '%d-%m-%Y.%H-%M-%S.%N')


INSTALLATION_PATH = $(shell echo $$INSTALLATION_PATH)
# If nothing is set in terminal, (in if - after command is nothing)
# assume instalation path is out proj root dir
ifeq ($(INSTALLATION_PATH),)
	INSTALLATION_PATH = $(PROJ_ROOR_DIR)
#	INSTALLATION_PATH = /usr/local/mycustombuild
endif

TARGET_DIR = $(INSTALLATION_PATH)/bins
# Full binary file (with path)
# ex: ../../bins/Mod-Template-1
TARGET = $(TARGET_DIR)/$(TARGET_NAME)

LIBRARY_DIR = $(INSTALLATION_PATH)/libs


# C++ compiler
CXX = $(shell echo $$CXX)
ifeq ($(CXX),)
	CXX = g++
endif

# C++ linker
LDXX = $(shell echo $$LDXX)
ifeq ($(LDXX),)
	LDXX = g++
endif

STDFLAG = -std=c++17
# ******** DO NOT MODIFY ABOVE ATTRIBUTES ******** #


# Include dirs
INC = -I./ -I$(PROJ_ROOT_DIR)/share_headers \
      -I ./if \
      -I ./inc \
      -I ./services/if \
      -I ./services/inc \
      -I ./networking/if \
      -I ./networking/inc \
      -I $(PROJ_ROOR_DIR_UT)/libs/boost \
      -I $(PROJ_ROOR_DIR_UT)/libs/unitTest/googlemock/include \
      -I $(PROJ_ROOR_DIR_UT)/libs/unitTest/googletest/include

# Choose release/debug
DEBUG = -pipe -g -Wall -W -fPIC
#RELEASE = -DNDEBUG -W -fPIC
RELEASE = -pipe -O3 -Wall -W -fPIC

# -D stands for DEFINE. If want to define any\
macro which is used in code for timestamp or git revision...
DEFINES = -DBUILD_TIMESTAMP_STR=\"$(BUILD_TIMESTAMP)\" \
          -DEINSTALLATION_PATH_STR=\"$(INSTALLATION_PATH)\"
#LD_OPT = -W1, -O1

#UNCOMENT IF LIKE TO SEE FOLLOWING WARNINGS. AT LEAST ONCE NEEDS TO BE \
RUN FOR EACH MODULE
WARN = -Wall -Wextra -Werror -Wwrite-strings -Wno-parentheses -pedantic \
       -Warray-bounds -Wno-unused-variable -Wno-unused-function \
       -Wno-unused-parameter -Wno-unused-result

# CCFLAGS = $(STDFLAG) $(BUILD_TYPE) $(DEFINES) $(WARN) $(INC)
CCFLAGS = $(STDFLAG) $(BUILD_TYPE) $(INC)

# Add dependency library here by separating them with space. Below example is \
to add libzmq, libm and libcustomlib

# Note: Add the "<path-to-library> -llibraryname" by keeping space between in as \
shown below. If library is present in the current directory, we can use path al L.

# DEP_LIBS = -lzmq -lm -L$(LIBRARY_DIR) -lcustomlib -L. -lnewlibincurrentdir

# RPATH IS USED FOR LINKING LIBS IN SPECIFIC PATH
# RPATH="-W1,-rpath,$(LIBRARY_DIR)/$(THIRD_PARTY_LIB_DIR)"
# In below path - linker will search for our libs
RPATH="-Wl,-rpath,$(LIBRARY_DIR)"

#LDFLAGS = $(DEBUG) $(PROF) -L$(LIBRARY_DIR) -L$(THIRD_PARTY_LIB_DIR) -fPIC \
-lpthread $(DEP_LIBS) $(RPATH)
LDFLAGS = $(DEP_LIBS) $(RPATH)



# STEP 1: If new file is created - add it here (.o) and (.cpp)
MAIN_SRC = ./common/mainMod-App-1.cpp
MAIN_OBJ = $(OBJ_DIR)/mainMod-App-1.o

SOURCE_1 = ./services/src/ServiceX.cpp
OBJ_1 = $(OBJ_DIR)/ServiceX.o

# WE MAY NEED TO ADD MORE DEPENDENCIES AS PER REQUIREMENT.\
1. DO NOT ADD EXTENSION C/CPP AS IT MAKES EASIER TO CREATE .o FILE \
2. ADD *.o IN ALL_OBJS. \
3. ADD INSTRUCTION TO BUILD TARGET (.o)

# STEP 2: Add obj var here
ALL_OBJS = $(MAIN_OBJ) $(OBJ_1)



# **** [TARGETS] ****

# Default make target ($ make)
# TARGET is full name (with path)
all: $(TARGET)
# Always the same
# ALL_OBJS - $^ (Multiple objs files)
# Gather and link all obj (.o) files
$(TARGET): $(ALL_OBJS)
	$(LDXX) $(LD_OPT) -o $@ $^ $(LDFLAGS)
# ----

# This below part is changing depend. what are we build
# $< will compile (to .o file) only one (main.cpp) file
$(MAIN_OBJ): $(MAIN_SRC)
	$(CXX) $(CCFLAGS) -o $@ -c $<

$(OBJ_1): $(SOURCE_1)
	$(CXX) $(CCFLAGS) -o $@ -c $<

#$(OBJ_2): $(SOURCE_2).cpp
#	$(CXX) $(CCFLAGS) -o $@ -c $<



# -------------------------------
# **** [ UNIT TEST TARGETs ] ****
# -------------------------------

# //// UNIT TEST NETWORKING ////
# Folder name
MODULE_NAME_UT = Mod-App-1_UT
# Binary file only name (*.out)
TARGET_NAME_UT = Mod-App-1_UT

PROJ_ROOR_DIR_UT = ../..
# Inside obj folder will be module folder
# OBJ_DIR_UT = $(PROJ_ROOR_DIR)/objs/$(MODULE_NAME)
TARGET_UT_DIR = $(PROJ_ROOR_DIR_UT)/bins/$(MODULE_NAME_UT)
# ----


# INPUT
UNITTEST_NETWORK_IN = networking/unitTest/unitTestNetworking.cpp \
		        src/HTTPSProxySrv.cpp \
	               networking/src/HTTPSClient.cpp

# OUTPUT
# Full binary file (with path)
# ex: ../../bins/Mod-App-1/Mod-App-1_UT
TARGET_UT = $(PROJ_ROOR_DIR_UT)/bins/$(MODULE_NAME_UT)/$(TARGET_NAME_UT)
# ----

CXXFLAGS_UT = -g -no-pie -std=c++17

# LIBS
# In googlemocklibs (libgmock.a libgmock_main.a libgtest.a libgtest_main.a)
LINK_LIBS_UT = -L$(PROJ_ROOR_DIR_UT)/libs/sslLibs \
		 -L$(PROJ_ROOR_DIR_UT)/libs/unitTest/googlemocklibs

# *.a libs - order is important
#         SSL            UNITTEST
LIBS_UT = -lssl -lcrypto -lgtest -lgtest_main -lgmock -lgmock_main -pthread


unitTestNet:
	g++ $(CXXFLAGS_UT) \
	$(UNITTEST_NETWORK_IN) \
	-o $(TARGET_UT) \
	$(INC) \
	$(LINK_LIBS_UT) \
	$(LIBS_UT)



# //// FULL SUBMODULE DIRs CREATION ////
build_objDir:
	@echo Creating object submodule directory if not exist
	mkdir -p $(OBJ_DIR)

build_utBinDir:
	@echo Creating unit test bin directory if not exist
	mkdir -p $(TARGET_UT_DIR)

# Copy *.h files to the share_headers folder
inslall:
	rsync -avz *.h $(PROJ_ROOT_DIR)/share_headers

clean:
	@echo Clean Build
	-rm $(ALL_OBJS)
	-rm $(TARGET)

.PHONY: clean build_dir all